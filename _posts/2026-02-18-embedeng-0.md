---
title: 임베디드 기사 - 개요
date: 2026-02-18
categories: [Study, Embedded Engineering]
tags: [digital logic, firmware, operating system, embedded software]     # TAG names should always be lowercase
---

## 개요

임베디드 소프트웨어 공부를 진행하며, 임베디드 기사를 취득해보고자 합니다. 이번 글에서는 2026 임베디드 기사 시험의 필기 및 실기 출제기준을 정리하며, 앞으로의 공부 내용은 해당 기준을 바탕으로 내용을 정리해보겠습니다.

> 임베디드 기사 출제기준 출처 : [Q-net](https://q-net.or.kr)

## 출제 기준 (필기)

### 임베디드하드웨어

| 주요항목 | 세부항목 | 세세항목 |
| :--- | :--- | :--- |
| **1. 논리회로** | 1. 논리회로 기초 | 1. 디지털 시스템의 정의 <br>2. 불 대수 <br>3. 논리식 간소화 <br>4. 수의 표현  |
| | 2. 조합논리회로 | 1. 각종 논리게이트 <br>2. 각종 조합논리회로(디코더, 인코더, 멀티플렉서, 가산기 패리티, 에러수정코드 등) <br>3. 조합논리회로 분석, 설계  |
| | 3. 순서논리회로 | 1. 래치와 플립플롭 <br>2. 각종 순서논리회로(레지스터, 카운터, 시프터 등) <br>3. 순서논리회로 분석, 설계  |
| | 4. 메모리 | 1. 각종 메모리(RAM, ROM, EPROM, EEPROM, NAND/NOR 플래시)  |
| | 5. HDL | 1. 프로그래머블 로직, FPGA <br>2. Verilog, VHDL <br>3. Verilog를 이용한 논리회로 설계  |
| **2. 컴퓨터 구조와 마이크로프로세서** | 1. CPU(중앙처리장치) 구조 | 1. CPU/마이크로프로세서의 구조 <br>2. 버스 시스템 <br>3. 명령어(instruction) 집합 구조 <br>4. 어드레싱 모드 <br>5. 마이크로 아키텍처 (파이프라인, 수퍼스칼라, 분기예측 등) <br>6. ARM CPU  |
| | 2. 메모리 시스템 | 1. 메모리 계층구조 <br>2. 캐시메모리 <br>3. MMU와 가상메모리 시스템, 페이징  |
| | 3. I/O 인터페이스 | 1. 입·출력장치의 매핑 <br>2. 폴링, 인터럽트 <br>3. DMA <br>4. 입·출력 버퍼링  |
| **3. 주변장치** | 1. 입·출력 포트 | 1. GPIO의 설정과 이용 <br>2. 입·출력 레지스터 (Command/Status) <br>3. 입·출력 포트 멀티플렉싱 <br>4. 데이터시트의 해석  |
| | 2. 주요주변장치 | 1. 시리얼 포트 <br>2. 타이머 <br>3. A/D, D/A 변환 <br>4. 각종 센서(초음파, 적외선, 온도, 모션센서 등) <br>5. 입·출력 버스(I2C, SPI, USB 등) <br>6. 통신장치(Ethernet, Wifi 등) <br>7. 전원제어 인터페이스 <br>8. 칩 실렉트 로직  |

### 임베디드펌웨어

| 주요항목 | 세부항목 | 세세항목 |
| :--- | :--- | :--- |
| **1. 펌웨어** | 1. 펌웨어 | 1. JTAG 하드웨어 <br>2. 스타트업 코드 <br>3. 메모리 초기화  |
| | 2. 부트로더 | 1. 부트로더의 종류와 기능 <br>2. OS 부트과정 <br>3. 플래시 메모리관리 <br>4. 초기 RAM Disk 이미지 <br>5. 네트워크 파일 시스템 이용 <br>6. 부트로더 작성 및 타깃시스템 이식  |
| **2. OS 포팅** | 1. 전원관리 | 1. 전원관리 하드웨어 <br>2. OS 전원관리 <br>3. 부트로더의 전원 관리  |
| | 2. 리눅스 내부구조 개요 및 포팅 | 1. 커널의 소스 트리 구조 <br>2. 커널 빌드 과정 개요 <br>3. 커널 구성(configuration) 방법  |
| | 3. 리눅스 부팅 | 1. 리눅스 부팅 과정 <br>2. init 스크립트 <br>3. busybox와 셀 <br>4. 커널 모듈 관리 <br>5. 공유 라이브러리 관리  |
| **3. 디바이스 드라이버 개발** | 1. 디바이스 드라이버 개념 | 1. 디바이스 드라이버의 개념 <br>2. 디바이스 드라이버의 종류 <br>3. 리눅스 커널 모듈 <br>4. 시스템 콜에 의한 드라이버 접근 <br>5. 커널 모듈 원격 디버깅  |
| | 2. 디바이스 드라이버와 커널 서비스 | 1. 커널의 주요자료 구조 <br>2. 디바이스 드라이버에서의 버퍼관리 <br>3. 커널 메모리 할당과 해제 <br>4. 상호배제 지원함수 <br>5. 동기/비동기 드라이버 개념 <br>6. 스케줄러를 이용한 대기 <br>7. 커널 타이머 <br>8. 세마포 <br>9. 인터럽트 서비스 <br>10. DMA(Direct Memory Access) 개념  |

### 임베디드플랫폼

| 주요항목 | 세부항목 | 세세항목 |
| :--- | :--- | :--- |
| **1. OS** | 1. OS의 기본개념 | 1. 가상머신 <br>2. 자원관리자 <br>3. OS의 분류(실시간 OS, 분산 OS 등)  |
| | 2. 프로세스관리 | 1. 스레드와 프로세스 <br>2. 프로세스 상태 <br>3. 스케줄링 기초  |
| | 3. CPU 스케줄링 | 1. 단일프로세서 스케줄링 기법 <br>2. 멀티프로세서 스케줄링 기법 <br>3. 실시간 스케줄링 기법  |
| | 4. 병행성 제어 | 1. 상호배제 <br>2. 세마포, 모니터 <br>3. 교착상태 <br>4. 교착상태 대처방법  |
| | 5. 메모리관리방법 | 1. 캐시메모리 <br>2. 가상메모리 <br>3. 페이징과 세그먼테이션  |
| | 6. 장치관리방법 | 1. 디스크 관리 <br>2. 파일시스템  |
| **2. 리눅스 커널프로그래밍** | 1. 리눅스 개요 | 1. 리눅스 설치 및 관리 <br>2. 커널 구조  |
| | 2. 커널 서비스 | 1. 시스템 콜 <br>2. 시그널과 인터럽트 <br>3. /proc, /sys 파일 시스템, kobject  |
| | 3. 메모리 관리 | 1. 주소 공간 및 구조 <br>2. 가상 메모리, 메모리 매핑 <br>3. 페이징, 스위칭, 캐싱 <br>4. 프로세스 관리 및 스케줄링  |
| | 4. 디바이스 관리 | 1. 디바이스 드라이버 구조 <br>2. 디바이스 파일 시스템 (devfs) <br>3. 하드웨어 I/O  |
| | 5. 파일시스템 | 1. 가상 파일시스템 (VFS) <br>2. LVM과 RAID <br>3. JFS  |
| | 6. 네트워크 | 1. 리눅스 TCP/IP 스택  |
| **3. 시스템 및 네트워크 프로그래밍** | 1. 프로세스 및 파일 처리 | 1. fork, exec 계열 <br>2. 저수준과 고수준 파일 핸들링  |
| | 2. 메모리 | 1. 메모리 할당 및 해제 <br>2. 메모리 정렬 및 검색 <br>3. 메모리 Lock  |
| | 3. IPC(Interprocess Communication) | 1. 메모리맵(mmap) <br>2. 공유메모리 <br>3. 세마포 <br>4. 메시지큐  |
| | 4. I/O 인터페이스 및 멀티플렉싱 | 1. PIPE와 FIFO <br>2. 소켓 <br>3. select, pselect <br>4. Non-blocking I/O <br>5. poll, epoll  |
| | 5. 스레드 | 1. 스레드 개념 <br>2. 스레드 생성 및 제어 <br>3. 스레드간 동기화 <br>4. 프로세스의 모듈화 <br>5. pthread API: 스레드의 생성 종료 <br>6. Mutex와 조건 변수 <br>7. Barrier, 여러 가지 locks <br>8. 스레드의 응용  |
| | 6. 시그널 기본 | 1. 시그널의 정의 <br>2. 시그널 핸들러 <br>3. 시그널전송 에러처리  |
| | 7. 컴퓨터 네트워크 | 1. 컴퓨터 네트워크 기본 <br>2. OSI 계층 프로토콜 <br>3. TCP, UDP, IP <br>4. 클라이언트/서버 프로그램  |
| | 8. 소켓 프로그래밍 | 1. 소켓의 정의 <br>2. TCP 소켓 <br>3. UDP 소켓 <br>4. 소켓 프로그래밍 응용  |

### 임베디드소프트웨어

| 주요항목 | 세부항목 | 세세항목 |
| :--- | :--- | :--- |
| **1. 데이터 구조** | 1. 데이터 구조의 이해 | 1. 알고리즘의 표현과 분석 <br>2. 배열 <br>3. 연결 리스트 <br>4. 스택과 큐 <br>5. 트리 <br>6. 그래프  |
| **2. 프로그래밍** | 1. C프로그래밍 | 1. 데이터 타입과 연산자 <br>2. 제어흐름 <br>3. 함수와 프로그램구조 <br>4. 포인터와 배열 <br>5. 구조 <br>6. 입력과 출력  |
| | 2. 객체지향 프로그래밍 | 1. 객체지향원리 <br>2. C++ 개요 <br>3. C++ 객체지향기능 <br>4. Java 개요 <br>5. Java 객체지향기능  |
| | 3. 멀티미디어 프로그래밍 | 1. 멀티미디어 정보표현 <br>2. 멀티미디어 압축 <br>3. 영상 및 신호 처리 <br>4. 멀티미디어 통신 <br>5. 편집도구 및 저작도구  |
| **3. 개발 방법론** | 1. 개발프로세스 | 1. 기본원리 <br>2. 프로세스 모델 <br>3. 요구사항 분석 <br>4. 시스템 아키텍처 <br>5. 설계기법 <br>6. 소프트웨어 테스팅 <br>7. UML 다이어그램  |
| | 2. 프로젝트관리 | 1. 프로젝트관리 개요 <br>2. 품질관리 <br>3. C 국제표준(ISO/IEC9899) 개요  |

## 출제 기준 (실기)

| 주요항목 | 세부항목 | 세세항목 |
| :--- | :--- | :--- |
| **1. 임베디드 하드웨어** | 1. 하드웨어 및 회로 분석하기 | 1. 조합논리회로 및 순서논리회로를 분석, 설계할 수 있다. <br>2. ROM, EPROM, SRAM, DRAM, 플래시 등 메모리 회로를 분석 및 설계할 수 있다.  |
| | 2. 임베디드 시스템 성능 및 구조 분석하기 | 1. 임베디드 프로세서를 위한 기계어 프로그램을 분석, 개발할 수 있다. <br>2. 임베디드 시스템의 성능에 영향을 미치는 요소를 분석하고 최적화할 수 있다. <br>3. 가상 메모리 시스템을 이해할 수 있다. <br>4. 임베디드 시스템을 구성하는 하드웨어 모듈들 사이의 인터페이스를 이해할 수 있다.  |
| | 3. 임베디드 시스템 주변장치 분석하기 | 1. 데이터시트를 분석하여 주변 장치의 상태를 읽고 입출력을 제어하는 프로그램을 작성할 수 있다. <br>2. 인터럽트 방식의 입·출력, DMA를 이용한 데이터 전송 프로그램을 작성할 수 있다. <br>3. 단순 입·출력, 스캐닝 입·출력, 시리얼 포트, 타이머 등을 이용하기 위한 프로그램을 작성할 수 있다. <br>4. 각종 센서를 이용하기 위한 프로그램을 작성할 수 있다.  |
| **2. 임베디드 펌웨어** | 1. 펌웨어 설계, 구현 및 테스팅하기 | 1. 컴파일 결과 만들어지는 ELF 포맷과 binutil 도구의 사용법을 이해할 수 있다. <br>2. 스타트업 코드를 이해하고 수정할 수 있다. <br>3. 칩 실렉트 로직을 이해하여 프로그램하며, 메모리 초기화를 할 수 있다. <br>4. OS의 부트과정을 이해할 수 있다. <br>5. OS의 부팅에 필요한 초기 RAM Disk를 이해하고 구성할 수 있다. <br>6. 플래시 메모리 제어 및 관리 프로그램을 작성할 수 있다. <br>7. OS의 전원관리 기법, 하드웨어의 전원관리 방법, 부트로더의 역할을 이해하고 프로그램 할 수 있다.  |
| | 2. 임베디드의 이해 및 포팅하기 | 1. 커널의 포팅 과정을 이해할 수 있다. <br>2. 부트로더의 동작을 이해하고 설명할 수 있다. <br>3. 교차개발 환경에 필요한 도구를 이용할 수 있다.  |
| | 3. 디바이스 드라이버 작성하기 | 1. 데이터시트를 이해하고 레지스터의 표현과 메모리 맵을 제시할 수 있다. <br>2. 디바이스 드라이버의 표준 API를 정의할 수 있다. <br>3. OS와의 연동을 위한 저수준의 OS API를 활용할 수 있다. <br>4. 디바이스 초기화 및 데이터 송·수신 프로그램을 작성할 수 있다. <br>5. Make파일을 이해하고 작성할 수 있다. <br>6. 인터럽트 처리를 할 수 있다. <br>7. 구현에 필요한 프로그래밍 언어들(C, C++, Java)을 이해할 수 있다.  |
| **3. 임베디드 플랫폼** | 1. 임베디드 OS의 이해하기 | 1. 커널의 구조를 이해하고 디렉터리의 역할을 설명할 수 있다. <br>2. 커널의 주요 기능에 관하여 이해할 수 있다.  |
| | 2. 임베디드 커널 프로그래밍하기 | 1. 프로세스 관리, 메모리 관리, 디바이스 관리, 파일시스템 관리를 위한 시스템 콜을 이해하고 활용할 수 있다. <br>2. 스레드 동기화를 위한 세마포, MUTEX 등을 이해하고 적용할 수 있다. <br>3. 소켓을 이용한 네트워크 프로그래밍을 할 수 있다. <br>4. IDE, 교차개발 환경에 필요한 도구를 이용할 수 있다.  |
| **4. 임베디드 소프트웨어** | 1. 임베디드 프로그램 분석 및 설계하기 | 1. 주어진 요구사항을 분석하여 UML 등 소프트웨어 공학적인 다이어그램으로 작성할 수 있다. <br>2. 설계 관련 산출물을 읽고 이해할 수 있다. <br>3. 개발 환경에 맞는 기술 문서 및 매뉴얼 작성을 할 수 있다.  |
| | 2. 임베디드 프로그램 작성하기 | 1. 구현에 필요한 프로그래밍 언어들(C, C++, Java)을 이해할 수 있다. <br>2. 주어진 설계결과를 이용하여 목표 프로그래밍언어로 표현할 수 있다. <br>3. 개발환경에 적합한 형태로 코딩을 수행할 수 있다.  |
| | 3. 개발도구 및 테스팅기법 활용하기 | 1. 컴파일러, IDE 등 개발에 필요한 도구를 이용할 수 있다. <br>2. 디버깅 도구를 이용하여 디버깅을 수행할 수 있다. <br>3. 사용하는 언어 및 개발 환경에 따라 단위 테스트를 위한 방법을 선정하고, 각 단위 간의 상호 작용을 고려한 테스트를 수행할 수 있다. <br>4. 단위 테스트를 위한 테스트 케이스를 작성할 수 있다.  |
| **5. 장애 대응** | 1. 장애 접수 처리하기 | 1. 임베디드SW 장애대응을 위하여 접수된 장애 내용을 유형에 따라 분류할 수 있다. <br>2. 임베디드SW 장애대응을 위하여 분류된 장애에 대해 장애등급을 지정할 수 있다. <br>3. 임베디드SW 장애대응을 위하여 처리절차에 따라 관련자에게 이관할 수 있다.  |
| | 2. 장애 대응 방안 수립하기 | 1. 임베디드SW 장애 대응 방안 수립을 위하여 식별된 장애의 영향력, 발생가능성, 발생시점을 분석하여 우선순위를 정할 수 있다. <br>2. 임베디드SW 장애 대응 방안 수립을 위하여 장애의 원인을 분석할 수 있다. <br>3. 임베디드SW 장애 대응 방안 수립을 위하여 장애 복구에 소요되는 시간 및 자원을 정의 할 수 있다. <br>4. 임베디드SW 장애 대응 방안 수립을 위하여 장애를 복구하기 위한 세부 계획을 수립할 수 있다.  |
| | 3. 장애 복구하기 | 1. 임베디드SW 장애복구를 위하여 장애 복구에 필요한 자원을 확보할 수 있다. <br>2. 임베디드SW 장애복구를 위하여 장애 원인을 제거할 수 있다. <br>3. 임베디드SW 장애복구를 위하여 장애 복구에 대한 작업내역을 기록할 수 있다. <br>4. 임베디드SW 장애복구 시 예외사항이 발생되었을 경우 비상조치를 실시할 수 있다. <br>5. 임베디드SW 장애복구 후 장애 처리 결과를 고객에게 전달할 수 있다.  |
| | 4. 장애 이력 관리하기 | 1. 임베디드SW 장애 이력관리를 위하여 장애 조치 완료 보고서를 작성할 수 있다. <br>2. 임베디드SW 개선을 위하여 장애 처리 결과에 대한 이력을 관리할 수 있다. <br>3. 임베디드SW 개선을 위하여 장애 이력을 분석하여 개선사항을 도출할 수 있다.  |
| | 5. 고객 만족도 조사하기 | 1. 임베디드SW 장애복구 완료 후 장애 처리결과에 대한 고객 만족도를 조사를 할 수 있다. <br>2. 임베디드SW 장애복구 완료 후 고객 만족도 조사결과를 분석할 수 있다. <br>3. 임베디드SW 장애복구에 대한 고객만족도 분석 결과를 활용하여 장애 대응 체계를 개선할 수 있다.  |